# 对话系统使用说明

## 目录
1. [系统概述](#系统概述)
2. [场景设置](#场景设置)
3. [对话UI创建](#对话ui创建)
4. [起名弹窗UI创建](#起名弹窗ui创建)
5. [脚本配置](#脚本配置)
6. [对话数据配置](#对话数据配置)
7. [事件系统配置](#事件系统配置)
8. [第0关卡配置](#第0关卡配置)
9. [使用示例](#使用示例)
10. [随时触发对话功能](#随时触发对话功能)

---

## 系统概述

对话系统包含以下核心组件：
- **DialogueManager**：对话管理器（单例）
- **DialogueData**：对话数据（ScriptableObject）
- **NameInputDialog**：起名弹窗管理器
- **Level0Manager**：第0关卡专用管理器
- **事件系统**：基于ScriptableObject的观察者模式

---

## 场景设置

### 1. 选择场景

对话系统需要在**持久化场景（Persistent Scene）**中设置，因为 `DialogueManager` 使用了 `DontDestroyOnLoad`。

**推荐场景**：`Assets/Scenes/Persistent.unity`（或你的持久化场景）

### 2. 场景层级结构

在持久化场景中，确保有以下结构：

```
Persistent Scene
├── [其他持久化对象]
└── DialogueSystem (GameObject)
    ├── DialogueManager (组件)
    └── [对话UI层级，见下方]
```

---

## 对话UI创建

### 步骤1：创建对话UI根对象

1. 在场景中选择 `DialogueSystem` GameObject（如果没有则创建）
2. 右键 → `UI` → `Canvas`，命名为 `DialogueCanvas`
3. 设置 Canvas 属性：
   - **Render Mode**: `Screen Space - Overlay`
   - **Sort Order**: 100（确保在最上层）

### 步骤2：创建对话面板结构

在 `DialogueCanvas` 下创建以下层级结构：

```
DialogueCanvas (Canvas)
├── DialoguePanel (GameObject)
│   ├── BackgroundMask (Image) - 背景遮罩
│   ├── DialogueContent (GameObject)    
│   │   ├── SpeakerImage (Image) - 说话人头像
│   │   ├── DialogueTextBG (Image) - 文本框背景
│   │   ├── DialogueTextContainer (GameObject)
│   │   │   ├── DialogueText (TextMeshProUGUI) - 对话文本
│   │   │   └── ContinueIndicator (GameObject) - 继续指示器（可选）
│   │   └── SpeakerNameText (TextMeshProUGUI) - 说话人名称
│   └── SkipButton (Button) - 跳过按钮（可选）
└── [其他UI...]
```

### 步骤3：配置各个UI组件

#### BackgroundMask (Image)
- **位置**：覆盖整个屏幕
- **颜色**：RGBA(0, 0, 0, 0.7) - 半透明黑色
- **Raycast Target**：✅ 勾选（用于点击继续）

#### DialoguePanel (GameObject)
- **位置**：屏幕底部或中央（根据你的UI设计）
- **RectTransform**：
  - Anchor: Bottom（如果底部显示）或 Center
  - Width: 屏幕宽度
  - Height: 根据设计调整（建议200-300）

#### SpeakerImage (Image)
- **位置**：对话面板左侧或中央
- **Preserve Aspect**：✅ 勾选
- **Raycast Target**：❌ 不勾选

#### DialogueTextBG (Image)
- **位置**：对话文本下方作为背景
- **Image Type**：Sliced（如果使用九宫格图片）
- **Raycast Target**：❌ 不勾选

#### DialogueText (TextMeshProUGUI)
- **位置**：在 DialogueTextBG 上方
- **字体大小**：根据设计调整（建议18-24）
- **对齐方式**：左上对齐
- **Raycast Target**：✅ 勾选（用于点击继续）

#### SpeakerNameText (TextMeshProUGUI)
- **位置**：说话人头像上方或对话文本上方
- **字体大小**：根据设计调整（建议16-20）

#### ContinueIndicator (GameObject)
- **位置**：对话文本右下角
- **内容**：可以是一个箭头图标或"点击继续"文字
- **初始状态**：❌ 禁用（脚本会自动控制显示/隐藏）

#### SkipButton (Button)
- **位置**：对话面板右上角
- **文本**："跳过" 或 "Skip"
- **初始状态**：根据需求决定是否显示

### 步骤4：添加点击继续功能

有两种方式实现点击继续：

**方式1：点击对话区域继续**
- 在 `DialoguePanel` 上添加 `Button` 组件
- 设置 `Button` 的 `Transition` 为 `None`（避免颜色变化）
- 或者直接在 `DialogueText` 上添加 `Button` 组件

**方式2：使用脚本处理**
- 当前 `DialogueManager` 已支持点击鼠标左键或按空格键继续
- 无需额外配置

---

## 起名弹窗UI创建

### 步骤1：创建起名弹窗根对象

在 `DialogueCanvas` 下创建：

```
DialogueCanvas
└── NameInputDialogRoot (GameObject)
    ├── BackgroundMask (Image) - 背景遮罩
    └── DialogPanel (GameObject)
        ├── TitleText (TextMeshProUGUI) - 标题（可选）
        ├── InputField (TMP_InputField) - 输入框
        └── ConfirmButton (Button) - 确认按钮
```

### 步骤2：配置起名弹窗组件

#### NameInputDialogRoot (GameObject)
- **初始状态**：❌ 禁用（脚本会自动控制）

#### BackgroundMask (Image)
- **位置**：覆盖整个屏幕
- **颜色**：RGBA(0, 0, 0, 0.7)
- **Raycast Target**：✅ 勾选

#### DialogPanel (GameObject)
- **位置**：屏幕中央
- **RectTransform**：
  - Anchor: Center
  - Width: 400-600
  - Height: 200-300
- **背景**：可以添加一个 `Image` 组件作为对话框背景

#### TitleText (TextMeshProUGUI)
- **文本**："请输入您的名字" 或 "Name Input"
- **字体大小**：20-24
- **对齐**：居中

#### InputField (TMP_InputField)
- **位置**：标题下方
- **Width**：300-400
- **Height**：40-50
- **Placeholder**："请输入名字..."
- **Character Limit**：10-20（可选）

#### ConfirmButton (Button)
- **位置**：输入框下方
- **文本**："确认" 或 "Confirm"
- **Width**：100-150
- **Height**：40-50

### 步骤3：添加NameInputDialog脚本

1. 在 `NameInputDialogRoot` 上添加 `NameInputDialog` 组件
2. 在 Inspector 中配置引用：
   - **Dialog Root**: 拖入 `NameInputDialogRoot` 自身
   - **Background Mask**: 拖入 `BackgroundMask`
   - **Dialog Panel**: 拖入 `DialogPanel`
   - **Title Text**: 拖入 `TitleText`（可选）
   - **Input Field**: 拖入 `InputField`
   - **Confirm Button**: 拖入 `ConfirmButton`
   - **Actual Player Name**: "工藤新一"（默认值）

---

## 脚本配置

### 配置 DialogueManager

1. 在场景中找到或创建 `DialogueSystem` GameObject
2. 添加 `DialogueManager` 组件
3. 在 Inspector 中配置：

#### 对话数据 (Dialogue Data)
- **Dialogue Data List**: 
  - 点击 `+` 添加元素
  - 拖入你创建的 `DialogueData` ScriptableObject 资源
  - 可以添加多个关卡的数据

#### UI引用 (UI References)
- **Dialogue Panel**: 拖入 `DialoguePanel` GameObject
- **Background Mask**: 拖入 `BackgroundMask` Image
- **Speaker Image**: 拖入 `SpeakerImage` Image
- **Speaker Name Text**: 拖入 `SpeakerNameText` TextMeshProUGUI
- **Dialogue Text**: 拖入 `DialogueText` TextMeshProUGUI
- **Dialogue Text BG**: 拖入 `DialogueTextBG` Image
- **Continue Indicator**: 拖入 `ContinueIndicator` GameObject（可选）
- **Skip Button**: 拖入 `SkipButton` Button（可选）

#### 设置 (Settings)
- **Allow Skip**: 是否允许跳过对话
- **Typewriter Speed**: 打字机速度（字符/秒），默认30
- **Mask Color**: 背景遮罩颜色，默认RGBA(0, 0, 0, 0.7)

#### 事件系统 (Event System)
- **Dialogue Start Event**: 拖入 `DialogueStartEventSO` 资源（需要先创建）
- **Dialogue End Event**: 拖入 `DialogueEndEventSO` 资源（需要先创建）

---

## 对话数据配置

### 步骤1：创建 DialogueData ScriptableObject

1. 在 Project 窗口中，右键 → `Create` → `Game` → `DialogueData`
2. 命名为 `DialogueData_Level0`（或其他名称）
3. 在 Inspector 中配置：

#### 关卡信息
- **Level Number**: 0（第0关卡）

#### 对话序列 (Dialogue Sequences)
点击 `+` 添加对话序列，每个序列包含：

**触发设置**：
- **Trigger Type**: 
  - `LevelStart` - 关卡开始
  - `LevelComplete` - 关卡完成
  - `WaveSpawn` - 波次生成（需要设置 Wave Number）
- **Wave Number**: 仅 `WaveSpawn` 类型需要

**对话内容**：
点击 `+` 添加对话条目（Dialogue Entry）：

- **说话人信息**：
  - **Speaker Name**: 角色名称（如"系统"、"工藤新一"）
  - **Speaker Image**: 角色头像 Sprite（可选）

- **对话内容**：
  - **Dialogue Text**: 对话文本内容
  - **Use Typewriter Effect**: 是否使用打字机效果
  - **Typewriter Speed**: 打字机速度（字符/秒）

- **文本框样式**：
  - **Text Box Background**: 文本框背景图（可选）

- **节点类型**：
  - **Node Type**: 
    - `Normal` - 普通对话
    - `NameInput` - 起名弹窗节点（对话会暂停，显示起名弹窗）
    - `CustomAction` - 自定义动作（预留）

### 步骤2：配置第0关卡对话示例

**初始对话序列**（Trigger Type: `LevelStart`）：
```
Entry 1:
- Speaker Name: "系统"
- Dialogue Text: "欢迎来到AI侦探系统..."
- Node Type: Normal

Entry 2:
- Speaker Name: "系统"
- Dialogue Text: "请输入您的名字："
- Node Type: NameInput  ← 这里会弹出起名弹窗

Entry 3:
- Speaker Name: "系统"
- Dialogue Text: "好的，工藤新一，让我们开始吧..."
- Node Type: Normal
```

**结尾对话序列**（Trigger Type: `LevelComplete`）：
```
Entry 1:
- Speaker Name: "系统"
- Dialogue Text: "第0关卡结束了..."
- Node Type: Normal
```

### 步骤3：将 DialogueData 添加到 DialogueManager

1. 在 `DialogueManager` 的 Inspector 中
2. 找到 **Dialogue Data List**
3. 点击 `+` 添加元素
4. 拖入你创建的 `DialogueData_Level0` 资源

---

## 事件系统配置

### 步骤1：创建事件 ScriptableObject

1. 在 Project 窗口中，右键 → `Create` → `Event` → `DialogueStartEventSO`
2. 命名为 `DialogueStartEvent`
3. 同样创建 `DialogueEndEventSO`，命名为 `DialogueEndEvent`

### 步骤2：配置 DialogueManager 的事件引用

1. 在 `DialogueManager` 的 Inspector 中
2. 找到 **Event System** 部分
3. 拖入 `DialogueStartEvent` 到 **Dialogue Start Event**
4. 拖入 `DialogueEndEvent` 到 **Dialogue End Event**

---

## 第0关卡配置

### 步骤1：创建 Level0Manager

1. 在场景中选择 `DialogueSystem` GameObject（或创建新的 GameObject）
2. 添加 `Level0Manager` 组件
3. 在 Inspector 中配置：

#### 事件监听
- **Dialogue End Event**: 拖入 `DialogueEndEvent` 资源

#### 线索奖励配置
- **Reward Clue IDs**: 线索ID列表
  - 点击 `+` 添加元素
  - 输入线索ID（如"卷宗"、"操作手册"）
  - 可以添加多个线索ID
  - 确保这些ID在 `ClueDatabaseSO` 中存在

### 步骤2：配置线索奖励

1. 在 `Level0Manager` 的 Inspector 中
2. 找到 **线索奖励配置** 部分
3. 在 **Reward Clue IDs** 列表中添加线索ID：
   - 点击 `+` 添加元素
   - 输入线索ID（如"卷宗"、"操作手册"）
   - 可以添加多个线索ID
4. 确认这些线索ID在 `ClueDatabaseSO` 中存在

---

## 使用示例

### 示例1：在代码中触发对话

```csharp
// 显示第0关卡的初始对话
DialogueManager.Instance.ShowDialogue(
    levelNumber: 0,
    triggerType: DialogueTriggerType.LevelStart,
    isForced: true  // 强制弹出，中断玩家操作
);

// 显示第0关卡的结尾对话
DialogueManager.Instance.ShowDialogue(
    levelNumber: 0,
    triggerType: DialogueTriggerType.LevelComplete,
    isForced: true
);
```

### 示例2：使用事件监听对话

```csharp
public class MyDialogueListener : MonoBehaviour
{
    [SerializeField] private DialogueEndEventSO dialogueEndEvent;
    
    private void OnEnable()
    {
        dialogueEndEvent.OnEventRaised += OnDialogueEnd;
    }
    
    private void OnDisable()
    {
        dialogueEndEvent.OnEventRaised -= OnDialogueEnd;
    }
    
    private void OnDialogueEnd(int levelNumber, DialogueTriggerType triggerType)
    {
        if (levelNumber == 0 && triggerType == DialogueTriggerType.LevelStart)
        {
            Debug.Log("第0关卡初始对话结束！");
            // 执行你的逻辑
        }
    }
}
```

### 示例3：在对话数据中插入起名弹窗

在 `DialogueData` 的对话序列中：
1. 添加一个对话条目
2. 设置 **Node Type** 为 `NameInput`
3. **Dialogue Text** 可以填写提示文字（可选，因为会显示弹窗）
4. 对话播放到这里时会自动暂停，显示起名弹窗
5. 玩家确认后，对话自动继续

---

## 随时触发对话功能

### 功能概述

"随时触发对话"功能允许你在游戏过程中随时触发 `WaveSpawn` 类型的对话。系统会自动管理波次编号，根据触发次数自动选择对应的对话。

**核心特点：**
- 自动波次管理：第1次触发 = waveNumber 0，第2次触发 = waveNumber 1，以此类推
- 自动关卡识别：从场景自动获取关卡编号
- 自动重置：切换关卡时自动重置计数器

### 配置步骤

#### 步骤1：配置场景映射表

1. 在 `DialogueManager` 的 Inspector 中
2. 找到 **场景映射配置（用于从场景获取关卡编号）** 部分
3. 在 **Scene Mappings** 列表中添加映射：
   - 点击 `+` 添加元素
   - **Scene Name**：输入场景名称（GameSceneSO的资源名称，如"TestFirstLevel"）
   - **Level Number**：输入对应的关卡编号（对应DialogueData中的levelNumber）
   - **Enabled**：勾选启用

**示例配置：**
```
Scene Mappings:
[0]
  Scene Name: "TestFirstLevel"
  Level Number: 0
  Enabled: ✓

[1]
  Scene Name: "Level1Scene"
  Level Number: 1
  Enabled: ✓
```

> **注意**：场景映射表与 `SceneDialogueTrigger` 的配置相同，可以复用。

#### 步骤2：配置 WaveSpawn 对话数据

在 `DialogueData` 中配置 `WaveSpawn` 类型的对话序列：

1. 打开你的 `DialogueData` ScriptableObject（如 `DialogueData_Level0`）
2. 在 **Dialogue Sequences** 中添加新的序列：
   - 点击 `+` 添加元素
   - **Trigger Type**：选择 `WaveSpawn`
   - **Wave Number**：设置波次编号
     - 第1波对话：`0`
     - 第2波对话：`1`
     - 第3波对话：`2`
     - 以此类推...

**示例配置：**
```
DialogueData_Level0
├── Level Number: 0
└── Dialogue Sequences
    ├── [序列1] Trigger Type: LevelStart
    ├── [序列2] Trigger Type: WaveSpawn, Wave Number: 0  ← 第1次触发
    ├── [序列3] Trigger Type: WaveSpawn, Wave Number: 1  ← 第2次触发
    ├── [序列4] Trigger Type: WaveSpawn, Wave Number: 2  ← 第3次触发
    └── [序列5] Trigger Type: LevelComplete
```

### 代码调用

#### 方式1：自动使用当前关卡（推荐）

```csharp
// 自动从场景获取关卡编号，触发下一波对话
DialogueManager.Instance.TriggerNextWaveSpawnDialogue(
    onComplete: () => {
        Debug.Log("WaveSpawn对话结束");
        // 执行对话结束后的逻辑
    },
    isForced: true  // 是否强制弹出（中断玩家操作）
);
```

#### 方式2：指定关卡编号

```csharp
// 明确指定关卡编号
DialogueManager.Instance.TriggerNextWaveSpawnDialogue(
    levelNumber: 0,  // 指定关卡编号
    onComplete: () => {
        Debug.Log("关卡0的WaveSpawn对话结束");
    },
    isForced: true
);
```

#### 方式3：获取触发次数

```csharp
// 获取指定关卡已触发的WaveSpawn对话次数
int count = DialogueManager.Instance.GetWaveSpawnTriggerCount(0);
Debug.Log($"关卡0已触发 {count} 次 WaveSpawn 对话");

// 下次触发将是第 (count + 1) 次，对应 waveNumber = count
```

#### 方式4：手动重置计数器

```csharp
// 重置指定关卡的触发次数（通常不需要手动调用，系统会在LevelStart时自动重置）
DialogueManager.Instance.ResetWaveSpawnTriggerCount(0);

// 重置所有关卡的触发次数
DialogueManager.Instance.ResetAllWaveSpawnTriggerCounts();
```

### 完整使用示例

#### 示例1：在按钮点击时触发对话

```csharp
using UnityEngine;
using UnityEngine.UI;

public class DialogueTriggerButton : MonoBehaviour
{
    [SerializeField] private Button triggerButton;
    
    private void Start()
    {
        if (triggerButton != null)
        {
            triggerButton.onClick.AddListener(OnTriggerButtonClicked);
        }
    }
    
    private void OnTriggerButtonClicked()
    {
        // 触发下一波WaveSpawn对话
        bool success = DialogueManager.Instance.TriggerNextWaveSpawnDialogue(
            onComplete: () => {
                Debug.Log("对话结束，可以继续游戏");
            },
            isForced: true
        );
        
        if (!success)
        {
            Debug.LogWarning("触发对话失败，可能是该波次对话不存在或对话正在播放中");
        }
    }
}
```

#### 示例2：在特定游戏事件时触发

```csharp
public class GameEventTrigger : MonoBehaviour
{
    private void OnPlayerFoundClue(ClueData clue)
    {
        // 玩家找到线索时，触发对话
        DialogueManager.Instance.TriggerNextWaveSpawnDialogue(
            onComplete: () => {
                Debug.Log("线索相关对话结束");
            },
            isForced: false  // 不强制，允许玩家继续操作
        );
    }
    
}
```

#### 示例3：检查对话是否存在再触发

```csharp
public class SafeDialogueTrigger : MonoBehaviour
{
    public void TryTriggerDialogue(int levelNumber)
    {
        // 先检查当前触发次数
        int triggerCount = DialogueManager.Instance.GetWaveSpawnTriggerCount(levelNumber);
        int waveNumber = triggerCount;  // 下次触发对应的波次编号
        
        // 检查对话数据是否存在
        DialogueData dialogueData = DialogueManager.Instance.dialogueDataList?.Find(
            d => d != null && d.levelNumber == levelNumber
        );
        
        if (dialogueData != null)
        {
            DialogueSequence sequence = dialogueData.GetDialogueSequence(
                DialogueTriggerType.WaveSpawn, 
                waveNumber
            );
            
            if (sequence != null && sequence.entries != null && sequence.entries.Length > 0)
            {
                // 对话存在，可以触发
                DialogueManager.Instance.TriggerNextWaveSpawnDialogue(
                    levelNumber: levelNumber,
                    onComplete: () => Debug.Log("对话结束"),
                    isForced: true
                );
            }
            else
            {
                Debug.LogWarning($"关卡 {levelNumber} 的 WaveSpawn 对话（波次 {waveNumber}）不存在");
            }
        }
    }
}
```

### 工作流程

```
1. 调用 TriggerNextWaveSpawnDialogue()
   ↓
2. 自动确定关卡编号
   - 如果指定了 levelNumber，使用指定值
   - 否则使用 currentLevelNumber
   - 如果仍未确定，从场景获取（使用场景映射表）
   ↓
3. 获取该关卡的触发次数（例如：2次）
   ↓
4. 计算波次编号（waveNumber = 2）
   ↓
5. 从 DialogueData 中查找 WaveSpawn + waveNumber=2 的对话序列
   ↓
6. 如果找到，调用 ShowDialogue() 显示对话
   ↓
7. 对话结束后，更新触发次数为 3
   ↓
8. 调用 onComplete 回调
```

### 计数器重置机制

**自动重置：**
- 当触发 `LevelStart` 对话时，系统会自动重置该关卡的 WaveSpawn 计数器
- 确保每次进入新关卡时，从 waveNumber 0 开始

**手动重置：**
- 如果需要手动重置，可以调用 `ResetWaveSpawnTriggerCount(levelNumber)`
- 通常不需要手动重置，除非有特殊需求

### 常见问题

#### Q1: 触发对话失败，提示"无法确定当前关卡编号"？

**原因：**
- 场景映射表未配置
- 当前场景不在映射表中
- SceneManager 未找到

**解决方法：**
1. 在 `DialogueManager` 的 Inspector 中配置场景映射表
2. 确保场景名称与 GameSceneSO 的资源名称完全匹配
3. 或者手动指定 `levelNumber` 参数

#### Q2: 触发对话失败，提示"该波次对话不存在"？

**原因：**
- DialogueData 中未配置该波次的 WaveSpawn 对话
- Wave Number 配置错误

**解决方法：**
1. 检查 DialogueData 中是否配置了对应的 WaveSpawn 序列
2. 确认 Wave Number 是否正确（第1次触发 = 0，第2次触发 = 1）
3. 如果不需要该波次对话，可以跳过或配置空对话

#### Q3: 对话触发次数不正确？

**原因：**
- 计数器未在关卡切换时重置
- 手动修改了计数器

**解决方法：**
1. 确保 LevelStart 对话正常触发（会自动重置计数器）
2. 检查是否有其他地方手动修改了计数器
3. 可以手动调用 `ResetWaveSpawnTriggerCount()` 重置

#### Q4: 如何知道当前是第几次触发？

```csharp
int levelNumber = 0;  // 你的关卡编号
int triggerCount = DialogueManager.Instance.GetWaveSpawnTriggerCount(levelNumber);
Debug.Log($"关卡 {levelNumber} 已触发 {triggerCount} 次，下次触发将是第 {triggerCount + 1} 次（waveNumber = {triggerCount}）");
```

---

## 常见问题

### Q1: 对话不显示？
- 检查 `DialogueManager` 的 `Dialogue Data List` 是否配置
- 检查 `Dialogue Panel` 的引用是否正确
- 检查对话数据的 `Level Number` 是否匹配

### Q2: 起名弹窗不显示？
- 检查 `NameInputDialog` 脚本是否添加到场景中
- 检查所有UI引用是否配置正确
- 检查 `NameInputDialogRoot` 的初始状态是否为禁用

### Q3: 对话结束后没有触发线索奖励？
- 检查 `Level0Manager` 是否添加到场景中
- 检查 `Dialogue End Event` 引用是否正确
- 检查对话数据的 `Trigger Type` 是否为 `LevelStart`
- 检查 `ClueManager.instance` 是否存在

### Q4: 对话结束后没有返回主菜单？
- 检查 `Level0Manager` 的 `Menu Scene` 是否配置
- 检查 `FadeManager.Instance` 是否存在
- 检查对话数据的 `Trigger Type` 是否为 `LevelComplete`

### Q5: 事件不触发？
- 确认事件 ScriptableObject 已创建
- 确认 `DialogueManager` 中的事件引用已配置
- 确认监听器已正确订阅事件

---

## 完整配置检查清单

- [ ] 对话UI已创建并配置
- [ ] `DialogueManager` 组件已添加并配置所有引用
- [ ] `DialogueData` ScriptableObject 已创建并配置
- [ ] 起名弹窗UI已创建并配置
- [ ] `NameInputDialog` 组件已添加并配置所有引用
- [ ] 事件 ScriptableObject 已创建
- [ ] `Level0Manager` 组件已添加并配置
- [ ] 线索ID常量与 `ClueDatabaseSO` 中的ID匹配
- [ ] 主菜单场景的 `GameSceneSO` 已创建并配置
- [ ] 所有组件都在持久化场景中

---

## 注意事项

1. **场景持久化**：确保 `DialogueManager` 在持久化场景中，因为它使用了 `DontDestroyOnLoad`
2. **UI层级**：对话UI应该在最高层级，确保不被其他UI遮挡
3. **事件引用**：所有事件 ScriptableObject 需要在 Project 中创建，不能是场景中的临时对象
4. **线索ID配置**：在 `Level0Manager` 的 Inspector 中配置 `Reward Clue IDs` 列表，确保线索ID与 `ClueDatabaseSO` 中的实际ID完全匹配
5. **起名弹窗**：无论玩家输入什么，实际保存的名字都是「工藤新一」（这是需求）

---

## 技术支持

如果遇到问题，请检查：
1. Unity Console 中的错误信息
2. 所有 Inspector 中的引用是否配置完整
3. 脚本中的 Debug.Log 输出

祝使用愉快！

